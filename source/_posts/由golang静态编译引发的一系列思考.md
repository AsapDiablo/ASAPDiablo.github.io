---
title: 由golang静态编译引发的一系列思考
date: 2020-09-02 17:54:38
categories: tech
tags: [golang, 静态编译, 链接]
---
# Golang是静态语言

## 1.定义
  **静态语言**:编译器在编译期可以执行数据类型检查，静态语言大多要求在变量使用前进行变量声明，例如C, Java. 但随着静态语言的发展，例如C++, Golang中也可以不用在使用前声明变量类型，即通过编译期动态类型推断。
  **动态语言**:代码在运行期进行数据类型决议，通常决议为赋值变量的类型。例如Python, shell等。
## 2.为什么Golang采用静态编译
  go程序在编译时采用静态链接的方式，将所依赖的库函数链接到可执行文件中，虽然可执行文件的体积增大，但也带来了便利:
    **a. 在分布式环境下可以减少因依赖库版本不一致带来的部署问题**
    **b. 加快了程序的执行时间(符号访问时间)**

## 3.链接
  链接阶段会执行地址和空间分配、符号决议(符号绑定)和重定位
### 静态链接
静态链接主要使用两步链接法:
**1. 空间分配**
 传统的空间分配方法为按序叠加法，直接将各个目标文件合并为一个目标文件，这样会导致:1.最终目标文件中有大量零散的程序段 2.段内碎片:若段只有1KB也会在目标文件中占有一个段大小。为了解决上述问题，静态链接时可以采用相似段合并的方法减少目标文件中的冗余段。
**2. 符号解析和重定位**
 利用段基址加段内偏移。在上一步空间分配后各个段(.data, .text, .bss)都会对应到虚拟地址空间中确定的地址。

### 动态链接
  早期计算机内存资源有限，为了节约程序执行时消耗的内存资源，采用动态链接的方式可以使得引用了相同库函数的多个程序在内存中公用一份库函数代码。动态链接分为装入时动态链接和运行时动态链接，由于动态链接使得代码段共享，因此导致符号重定位开销变大。
#### PIC位置无关代码
#### PLT延迟绑定
    延迟绑定技术通过过程链接表(PLT)实现
#### DLL Hell
**1. 增加虚函数**
a.原本无虚函数: 在类内存起始处增加虚表指针
b.原有虚函数: 虚表指针不变，虚表会增加对象。若增加的虚函数在原有虚函数之前，则导致函数调用混乱。
**2. 新增成员变量**
a.类末尾新增:实际分配内存减少，若访问新增成员则导致内存越界
b.类中间新增:直接导致类成员内存偏移

## 4.问题分析
  **a. 为什么说Golang静态编译在分布式环境下的部署优于动态链接?**
  我理解程序运行在没有docker(运行环境打包)支持的分布式环境，例如直接在Linux环境下部署程序的话，使用动态链接的方式会导致依赖的库各不相同。例如开发机版本依赖libboost1.0而服务器依赖libboost1.1，这样导致动态链接后的目标文件可能出现DLL Hell.因此在分布式程序的部署，较好的实践是采用静态链接的方式，直接打包可执行文件或将可执行文件的运行环境一起打包。
  **b. 为什么说动态链接在更新上优于静态链接?**
  基于单机情况，若静态链接依赖库函数更新了，则会触发重新编译和链接，需要发布新的可执行文件。采用动态链接的方式，若程序依赖的libboost1.0.so若需要更新为libboost1.1.so,可以直接在文件系统使用mv覆盖或者rm之后再cp/mv(不能直接cp new old，会导致segmentfault)，然后程序在装载或运行时便会链接到新的动态库。


